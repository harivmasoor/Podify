{"version":3,"file":"main.js","mappings":"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","sources":["webpack://podify/./src/audioCapture.js","webpack://podify/webpack/bootstrap","webpack://podify/./src/webPlayer.js","webpack://podify/./src/searchBar.js","webpack://podify/./src/index.js"],"sourcesContent":["const captureAudioButton = document.getElementById('captureAudio');\nlet mediaRecorder;\nlet audioChunks = [];\nconst chunkDuration = 5000; // 5 seconds for this example. Adjust as needed.\nconst overlapDuration = 250; // 0.25 seconds overlap.\n\nfunction initializeAudioCapture() {\n    captureAudioButton.addEventListener('click', () => {\n        if (typeof mediaRecorder === 'undefined' || mediaRecorder.state === 'inactive') {\n            const constraints = {\n                audio: {\n                    echoCancellation: false,\n                    autoGainControl: false,\n                    noiseSuppression: false,\n                    latency: 0\n                }\n            };\n\n            navigator.mediaDevices.getUserMedia(constraints)\n                .then(stream => {\n                    mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm;codecs=opus' });\n                    audioChunks = [];\n\n                    mediaRecorder.ondataavailable = onDataAvailable;\n                    mediaRecorder.onstop = onRecordingStop;\n\n                    mediaRecorder.start(chunkDuration - overlapDuration);\n                    captureAudioButton.textContent = \"Stop Recording\";\n                })\n                .catch(err => {\n                    console.error('Error accessing the microphone', err);\n                });\n        } else if (mediaRecorder.state === 'recording') {\n            mediaRecorder.stop();\n            captureAudioButton.textContent = \"Capture Sound\";\n        }\n    });\n}\n\nfunction onDataAvailable(event) {\n    audioChunks.push(event.data);\n\n    if (audioChunks.length > 1) {\n        sendToAPI(audioChunks[0]); // Send the oldest chunk.\n        audioChunks = audioChunks.slice(-1); // Keep only the latest chunk.\n    }\n}\n\nfunction onRecordingStop() {\n    const audioBlob = new Blob(audioChunks, { type: 'audio/webm;codecs=opus' });\n\n    // TODO: Send the audioBlob to Whisper API for transcription\n\n    // Clear the audioChunks array for the next session\n    audioChunks = [];\n}\n\n// Placeholder function to simulate sending data to the API\nasync function sendToAPI(data) {\n    const formData = new FormData();\n    formData.append('audio', new Blob([data], { type: 'audio/webm;codecs=opus' }));\n\n    try {\n        const response = await fetch('https://podify-backend.onrender.com/transcribe', {\n            method: 'POST',\n            body: formData\n        });\n\n        if (!response.ok) {\n            throw new Error('Network response was not ok');\n        }\n\n        const result = await response.json();\n        displayTranscription(result); // Display the transcribed result on the webpage\n    } catch (error) {\n        console.error('There was a problem with the fetch operation:', error.message);\n    }\n}\n\nfunction displayTranscription(result) {\n    const transcriptionBox = document.getElementById('transcriptionBox');\n    if (result && result.data) {\n        transcriptionBox.value = result.data.transcript;\n    } else {\n        transcriptionBox.value = \"Failed to get transcription.\";\n    }\n}\n\n\n// Initialize on page load\ndocument.addEventListener('DOMContentLoaded', () => {\n    initializeAudioCapture();\n});\n\n\n// // audioCapture.js\n\n// const captureAudioButton = document.getElementById('captureAudio');\n// let mediaRecorder;\n// let audioChunks = [];\n\n// function initializeAudioCapture() {\n//     captureAudioButton.addEventListener('click', () => {\n//         if (typeof mediaRecorder === 'undefined' || mediaRecorder.state === 'inactive') {\n//             const constraints = {\n//                 audio: {\n//                     echoCancellation: false,\n//                     autoGainControl: false,\n//                     noiseSuppression: false,\n//                     latency: 0\n//                 }\n//             };\n\n//             navigator.mediaDevices.getUserMedia(constraints)\n//                 .then(stream => {\n//                     mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm;codecs=opus' });\n//                     audioChunks = [];\n\n//                     mediaRecorder.ondataavailable = event => {\n//                         audioChunks.push(event.data);\n//                     };\n\n//                     mediaRecorder.onstop = () => {\n//                         const audioBlob = new Blob(audioChunks, { type: 'audio/webm;codecs=opus' });\n//                         const audioUrl = URL.createObjectURL(audioBlob);\n//                         const audio = new Audio(audioUrl);\n//                         audio.play();\n//                         downloadAudio(audioUrl);\n//                     };\n\n//                     mediaRecorder.start();\n//                     captureAudioButton.textContent = \"Stop Recording\";\n//                 })\n//                 .catch(err => {\n//                     console.error('Error accessing the microphone', err);\n//                 });\n//         } else if (mediaRecorder.state === 'recording') {\n//             mediaRecorder.stop();\n//             captureAudioButton.textContent = \"Capture Sound\";\n//         }\n//     });\n// }\n\n// function downloadAudio(url) {\n//     const a = document.createElement('a');\n//     a.href = url;\n//     a.download = 'recorded-audio.webm';\n//     a.click();\n// }\n\n// // Initialize on page load\n// document.addEventListener('DOMContentLoaded', () => {\n//     initializeAudioCapture();\n// });\n\n\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\n\nlet currentAccessToken = null;\nlet currentSpotifyUri = null;\n\nexport function setupWebPlayer(accessToken) {\n    currentAccessToken = accessToken;\n\n\n    // Adding event listener to the Spotify logo\n    const spotifyLogo = document.getElementById('spotifyLogo');\n    spotifyLogo.addEventListener('click', redirectToSpotify);\n\n    // Fetch and update the current playing song after user logs in\n    fetchCurrentPlaying();\n}\n\nfunction redirectToSpotify() {\n    if (currentSpotifyUri) {\n        const spotifyURL = `https://open.spotify.com/${currentSpotifyUri.split(':').slice(1).join('/')}`;\n        window.open(spotifyURL, '_blank');\n    } else {\n        console.error('No track is currently being played.');\n    }\n}\n\n\nasync function fetchWithRetry(endpoint, options, maxRetries = 3) {\n    for (let i = 0; i < maxRetries; i++) {\n        try {\n            const response = await fetch(endpoint, options);\n            if (response.ok) return response;\n            if (i === maxRetries - 1) throw new Error('Max retries reached');\n        } catch (err) {\n            console.error(`Attempt ${i + 1} failed. Retrying...`);\n            await new Promise(res => setTimeout(res, 2000)); // wait for 2 seconds\n        }\n    }\n}\n\nexport async function playItem(itemId, itemType) {\n    const endpoint = `https://api.spotify.com/v1/me/player/play`;\n    const headers = {\n        'Authorization': `Bearer ${currentAccessToken}`,\n        'Content-Type': 'application/json',\n    };\n    \n    let body;\n\n    // This part identifies the type of item and prepares the body for the play request.\n    // It also updates the currentSpotifyUri variable with the URI of the current item.\n    if (itemType === 'track' || itemType === 'episode') {\n        currentSpotifyUri = `spotify:${itemType}:${itemId}`;\n        body = {\n            uris: [currentSpotifyUri],\n        };\n    } else {\n        currentSpotifyUri = `spotify:${itemType}:${itemId}`;\n        body = {\n            context_uri: currentSpotifyUri,\n        };\n    }\n\n    try {\n        console.log(\"Attempting to play\", body);\n        const response = await fetchWithRetry(endpoint, {\n            method: 'PUT',\n            headers: headers,\n            body: JSON.stringify(body),\n        });\n\n        if (!response.ok) {\n            const errorBody = await response.json();\n            console.error(\"Play response:\", errorBody);\n            throw new Error(`Unable to play ${itemType}: ${response.statusText}`);\n        }\n\n        console.log(`Successfully started playing ${itemType} with ID: ${itemId}`);\n    } catch (error) {\n        console.error('Error in web player:', error);\n        handlePlaybackError(error);\n    }\n    \n    const selectedItem = Array.from(document.getElementById('searchResults').children).find(item => item.dataset.id === itemId);\n    if (selectedItem) {\n        const currentImage = document.getElementById('currentImage');\n        currentImage.src = selectedItem.dataset.image;\n        document.getElementById('currentTitle').textContent = selectedItem.dataset.name;\n        currentImage.style.display = 'block';  // Show the image\n    }\n}\nasync function fetchCurrentPlaying(retries = 3) {\n    const endpoint = `https://api.spotify.com/v1/me/player`; \n    const headers = {\n        'Authorization': `Bearer ${currentAccessToken}`,\n        'Content-Type': 'application/json',\n    };\n\n    if (retries <= 0) {\n        console.warn(\"Max retries reached. Unable to fetch currently playing track.\");\n        return;\n    }\n\n    try {\n        const response = await fetchWithRetry(endpoint, { headers: headers });\n        if (response.ok) {\n            const text = await response.text();\n            if (text) {\n                try {\n                    const data = JSON.parse(text);\n                    updateCurrentPlaying(data);\n                } catch (e) {\n                    console.error(\"Failed to parse JSON. Response text:\", text);\n                    throw e;\n                }\n            } else {\n                console.warn(\"No track is currently playing or the response is empty. Retrying...\");\n                setTimeout(() => fetchCurrentPlaying(retries - 1), 2000);  // retry after 2 seconds\n            }\n        } else {\n            const text = await response.text();\n            console.error(\"Error response:\", text);\n        }\n    } catch (error) {\n        console.error('Error fetching current playing:', error);\n    }\n}\n\n\nfunction updateCurrentPlaying(data) {\n    if (data && data.item) {\n        const track = data.item;\n        currentSpotifyUri = track.uri;\n\n        // Set the src. The load event will trigger once the image is loaded.\n        currentImage.src = track.album.images[0].url;\n\n        document.getElementById('currentTitle').textContent = track.name;\n    } else {\n        console.warn('No track is currently being played.');\n    }\n}\n\n\n\nlet spotifySDKReady = new Promise((resolve) => {\n    window.onSpotifyWebPlaybackSDKReady = () => {\n        resolve();\n    };\n});\n\nexport async function checkWebPlaybackSDKCompatibility() {\n    await spotifySDKReady;  // wait for the SDK to be ready\n    return window.Spotify?.Player?.isSupported() ?? false;\n}\n\nfunction handlePlaybackError(error) {\n    console.error('Web Playback SDK error:', error);\n    if (error.message.includes(\"Max retries reached\")) {\n        alert('There seems to be a connection issue with Spotify. Please try again in a few moments.');\n    } else if(error.message.includes(\"Playback cannot be started from this context\")) {\n        alert('Cannot play this item. Please choose another.');\n    } else {\n        alert('Playback error. Please try again later.');\n    }\n}\n","import { playItem } from './webPlayer.js'; \nlet accessToken = null;\n\nexport function setupSearch(accessTokenValue) {\n  accessToken = accessTokenValue;\n\n  const searchInput = document.getElementById('searchInput');\n  const searchResults = document.getElementById('searchResults');\n  searchInput.style.display = 'block';\n  let timer;\n\n  searchInput.addEventListener('input', (e) => {\n    if (e.target.value) {\n      searchResults.style.border = '1px solid #ccc';\n    } else {\n      searchResults.style.border = 'none';\n    }\n    clearTimeout(timer);\n    timer = setTimeout(() => {\n      searchSpotify(e.target.value);\n    }, 500);\n  });\n}\n\nasync function refreshToken() {\n  try {\n    const response = await fetch(`https://podify-backend.onrender.com/refresh_token?refresh_token=${localStorage.getItem('refresh_token')}`);\n    const data = await response.json();\n    accessToken = data.access_token;\n    localStorage.setItem('access_token', accessToken);\n  } catch (error) {\n    console.error('Error refreshing token:', error);\n  }\n}\n\nasync function searchSpotify(query) {\n  const searchEndpoint = `https://api.spotify.com/v1/search?q=${encodeURIComponent(query)}&type=artist,show,episode,track&limit=5`;\n  const headers = {\n    'Authorization': `Bearer ${accessToken}`,\n    'Content-Type': 'application/json',\n  };\n\n  try {\n    let response = await fetch(searchEndpoint, { headers: headers });\n    \n    // If token expired (status 401), refresh and retry\n    if (response.status === 401) {\n      await refreshToken();\n      response = await fetch(searchEndpoint, { headers: headers });\n    }\n\n    const data = await response.json();\n    let trackResults = [];\n    let artistResults = [];\n    let episodeResults = [];\n    let showResults = [];\n\n    // Extract and structure data for tracks\n    if (data.tracks && data.tracks.items) {\n      trackResults = data.tracks.items.map(item => ({\n          type: 'track',\n          id: item.id,\n          name: item.name,\n          image: item.album.images[0].url,\n          popularity: item.popularity\n      }));\n    }\n\n    // Extract and structure data for artists\n    if (data.artists && data.artists.items) {\n      artistResults = data.artists.items.map(item => ({\n          type: 'artist',\n          id: item.id,\n          name: item.name,\n          image: item.images[0] ? item.images[0].url : null,\n          popularity: item.popularity\n      }));\n    }\n    \n    if (data.episodes && data.episodes.items) {\n      episodeResults = data.episodes.items.map(item => ({\n          type: 'episode',\n          id: item.id,\n          name: item.name,\n          image: item.images[0].url\n      }));\n    }\n    if (data.shows && data.shows.items) {\n      showResults.push(...data.shows.items.map(item => ({\n        type: 'show',\n        id: item.id,\n        name: item.name,\n        image: item.images[0]?.url || '',\n      })));\n    }\n    if (data.artists && data.artists.items) {\n  artistResults.push(...data.artists.items.map(item => ({\n    type: 'artist',\n    id: item.id,\n    name: item.name,\n    image: item.images[0]?.url || '', // Use the first image or an empty string as a fallback\n  })));\n}\n\n\n    // Sort tracks and artists by popularity\n    trackResults.sort((a, b) => b.popularity - a.popularity);\n    artistResults.sort((a, b) => b.popularity - a.popularity);\n\n    // Combine the results in desired order\n    const results = [...showResults,...trackResults, ...artistResults, ...episodeResults];\n\n    // Call the displayResults function with the search results\n    displayResults(results);\n    \n    return results;\n  } catch (error) {\n    console.error('Error searching Spotify:', error);\n    return [];\n  }\n}\n\n\nfunction displayResults(results) {\n  const resultsContainer = document.getElementById('searchResults');\n  resultsContainer.innerHTML = '';\n\n  const episodeResults = results.filter(result => result.type === 'episode');\n  const trackResults = results.filter(result => result.type === 'track');\n  const artistResults = results.filter(result => result.type === 'artist');\n  const showResults = results.filter(result => result.type === 'show');\n\nif (artistResults.length > 0) {\n  const geniusHeader = document.createElement('h2');\n  geniusHeader.textContent = 'Geniuses';\n  resultsContainer.appendChild(geniusHeader);\n\n  artistResults.forEach(result => appendResultToContainer(result, resultsContainer));\n}\n\nif (showResults.length > 0) {\n  const mogulHeader = document.createElement('h2');\n  mogulHeader.textContent = 'Moguls';\n  resultsContainer.appendChild(mogulHeader);\n\n  showResults.forEach(result => appendResultToContainer(result, resultsContainer));\n}\n  if (episodeResults.length > 0) {\n    const podHeader = document.createElement('h2');\n    podHeader.textContent = 'Pods';\n    resultsContainer.appendChild(podHeader);\n\n    episodeResults.forEach(result => appendResultToContainer(result, resultsContainer));\n  }\n\n  if (trackResults.length > 0) {\n    const bangerHeader = document.createElement('h2');\n    bangerHeader.textContent = 'Bangers';\n    resultsContainer.appendChild(bangerHeader);\n\n    trackResults.forEach(result => appendResultToContainer(result, resultsContainer));\n  }\n}\n\nfunction appendResultToContainer(result, container) {\n  const resultElement = document.createElement('div');\n  resultElement.className = 'resultItem';\n  resultElement.dataset.id = result.id;\n  resultElement.dataset.type = result.type;\n  resultElement.dataset.name = result.name;\n  resultElement.dataset.image = result.image;\n  resultElement.innerHTML = `<img src=\"${result.image}\" alt=\"${result.name}\"/> ${result.name}`;\n  resultElement.addEventListener('click', handleResultClick);\n  container.appendChild(resultElement);\n}\n\n\nasync function handleResultClick(e) {\n  const type = e.currentTarget.dataset.type;\n  const id = e.currentTarget.dataset.id;\n\n  if (type === 'artist') {\n    await getArtistTopTracks(id);\n  } else if (type === 'show') {\n    await getShowEpisodes(id);\n  } else if (type === 'track' || type === 'episode') {\n    playItem(id, type);\n  }\n}\n\n\n\nasync function getArtistTopTracks(artistId) {\n  const topTracksEndpoint = `https://api.spotify.com/v1/artists/${artistId}/top-tracks?market=US`;\n  const headers = {\n    'Authorization': `Bearer ${accessToken}`,\n    'Content-Type': 'application/json',\n  };\n\n  try {\n    let response = await fetch(topTracksEndpoint, { headers: headers });\n\n    if (response.status === 401) {\n      await refreshToken();\n      response = await fetch(topTracksEndpoint, { headers: headers });\n    }\n\n    const data = await response.json();\n    const topTracks = data.tracks.map(track => ({\n      type: 'track',\n      id: track.id,\n      name: track.name,\n      image: track.album.images[0].url,\n    }));\n\n    displayResults(topTracks);\n\n  } catch (error) {\n    console.error('Error getting artist top tracks:', error);\n  }\n}\n\n\nasync function getShowEpisodes(showId) {\n  const episodesEndpoint = `https://api.spotify.com/v1/shows/${showId}/episodes?market=US&limit=10`;\n  const headers = {\n    'Authorization': `Bearer ${accessToken}`,\n    'Content-Type': 'application/json',\n  };\n\n  try {\n    let response = await fetch(episodesEndpoint, { headers: headers });\n\n    if (response.status === 401) {\n      await refreshToken();\n      response = await fetch(episodesEndpoint, { headers: headers });\n    }\n\n    const data = await response.json();\n    const episodes = data.items.map(episode => ({\n      type: 'episode',\n      id: episode.id,\n      name: episode.name,\n      image: episode.images[0].url,\n    }));\n\n    displayResults(episodes);\n\n  } catch (error) {\n    console.error('Error getting show episodes:', error);\n  }\n}\n\n\n\n","// Description: The main JavaScript file for the Podify web app.\nimport { setupSearch } from './searchBar.js';\nimport { setupWebPlayer, checkWebPlaybackSDKCompatibility } from './webPlayer.js';\nimport { initializeAudioCapture } from './audioCapture.js';\n\n\nlet updateSeekBarInterval;  // Declare the variable at a scope accessible by all your functions\nlet accessToken; // Move the declaration of accessToken to a higher scope\nlet player;  // Declare the player variable at a scope accessible by all your functions\nlet isPlaying = false;  // To track playback state\nlet currentPosition = 0;  // To track the current position of the track\nlet trackDuration = 0;  // To track the duration of the track\n\n// Function to get user's Spotify profile\nfunction getUserProfile(token) {\n    const headers = {\n        Authorization: `Bearer ${token}`,\n        'Content-Type': 'application/json',\n    };\n\n    fetch('https://api.spotify.com/v1/me', { headers: headers })\n        .then(response => response.json())\n        .then(data => {\n            const username = data.display_name;\n            renderUsername(username);\n        })\n        .catch(error => {\n            console.error('Error fetching user profile:', error);\n        });\n}\n\n// Function to render the user's name\nfunction renderUsername(username) {\n    const usernameElement = document.getElementById('username');\n    usernameElement.textContent = username;\n}\n\n// Playback control functions\nfunction togglePlay() {\n    if (isPlaying) {\n        player.pause().then(() => {\n            console.log('Paused Playback');\n            isPlaying = false;\n            document.getElementById('playPause').textContent = '▶️';\n            clearInterval(updateSeekBarInterval);  // Stop updating the seek bar\n        });\n    } else {\n        player.resume().then(() => {\n            console.log('Resumed Playback');\n            isPlaying = true;\n            document.getElementById('playPause').textContent = '⏸️';\n            updateSeekBarInterval = setInterval(updateSeekBar, 1000);  // Resume updating the seek bar\n        });\n    }\n}\n\n\nfunction rewindTrack() {\n    player.getCurrentState().then(state => {\n        if (state) {\n            const newPosition = Math.max(state.position - 15000, 0); // ensure position is not negative\n            player.seek(newPosition).then(() => {\n                console.log('Rewound 15 seconds!');\n            });\n        }\n    });\n}\n\nfunction fastForwardTrack() {\n    player.getCurrentState().then(state => {\n        if (state) {\n            const newPosition = state.position + 15000;\n            player.seek(newPosition).then(() => {\n                console.log('Fast-forwarded 15 seconds!');\n            });\n        }\n    });\n}\n\nfunction onSuccessfulLogin() {\n    // Display the current image, Spotify logo, and web player\n    // document.getElementById('currentImage').style.display = 'block';\n    const currentImage = document.getElementById('currentImage');\n    currentImage.addEventListener('load', function() {\n        this.style.display = 'block';\n    });\n    \n    document.getElementById('spotifyLogo').style.display = 'block'; // changed to getElementById\n    document.getElementById('webPlayer').style.display = 'flex';\n    \n    // For elements with class, use querySelector\n    document.querySelector('.playerControls').style.display = 'flex'; \n    document.querySelector('.playerControls button').style.display = 'flex'; \n    \n    document.getElementById('seekBarContainer').style.display = 'flex';\n    document.getElementById('currentTime').style.display = 'block'; // removed '#'\n    document.getElementById('totalTime').style.display = 'block'; // corrected capitalization to match HTML ID\n    \n    // Removed the line for '.player-controls' as it doesn't match any class in the provided HTML.\n    \n}\n\n// Initialize all event listeners\nfunction initializeEventListeners() {\n    // Login button event\n    const loginButton = document.getElementById('loginButton');\n    loginButton.addEventListener('click', () => {\n        window.location.href = 'https://podify-backend.onrender.com/login';\n    });\n\n    // Search input events\n    const searchInput = document.getElementById('searchInput');\n    const searchResults = document.getElementById('searchResults');\n    searchInput.addEventListener('input', () => {\n        if (searchInput.value.length > 0) {\n            searchResults.style.display = 'block';\n        } else {\n            searchResults.style.display = 'none';\n        }\n    });\n\n    searchInput.addEventListener('focus', (event) => {\n        event.preventDefault();\n    });\n\n    // Player control events\n    document.getElementById('playPause').addEventListener('click', togglePlay);\n    document.getElementById('rewind').addEventListener('click', rewindTrack);\n    document.getElementById('fastForward').addEventListener('click', fastForwardTrack);\n    initializeAudioCapture();  \n}\n\n// The main code that runs when the window loads\nwindow.addEventListener('load', () => {\n    const hash = window.location.hash.substring(1);\n    const hashParams = new URLSearchParams(hash);\n\n    if (hashParams.has('access_token')) {\n        document.getElementById('loginButton').style.display = 'none';  // Hide the login button\n\n        accessToken = hashParams.get('access_token'); \n        const tokenType = hashParams.get('token_type');\n        const expiresIn = hashParams.get('expires_in');\n        const searchContainer = document.getElementById('search-container');\n        searchContainer.style.display = 'block';\n\n        console.log({\n            access_token: accessToken,\n            token_type: tokenType,\n            expires_in: expiresIn,\n        });\n\n        getUserProfile(accessToken);\n        setupSearch(accessToken);\n        if (checkWebPlaybackSDKCompatibility()) {\n            setupWebPlayer(accessToken);\n        } else {\n            alert(\"Device not suitable for playback\");\n        }\n        onSuccessfulLogin();\n    }\n});\n\nwindow.onSpotifyWebPlaybackSDKReady = () => {\n    player = new Spotify.Player({\n        name: 'Your Web Player Name',\n        getOAuthToken: callback => {\n            callback(accessToken);\n        }\n    });\n\n    player.addListener('player_state_changed', state => {\n        console.log(state);\n        if (state) {\n            const trackDuration = state.track_window.current_track.duration_ms;\n            const currentPosition = state.position;\n    \n            document.getElementById('seekBar').max = trackDuration;\n            document.getElementById('seekBar').value = currentPosition;\n    \n            // Update the time display\n            document.getElementById('currentTime').textContent = formatTime(currentPosition);\n            document.getElementById('totalTime').textContent = formatTime(trackDuration);\n        }\n        isPlaying = !state.paused;\n        if (isPlaying) {\n            document.getElementById('playPause').textContent = '⏸️';\n        } else {\n            document.getElementById('playPause').textContent = '▶️';\n        }\n    });\n\n    player.addListener('ready', ({ device_id }) => {\n        console.log('Ready with Device ID', device_id);\n\n        updateSeekBarInterval = setInterval(updateSeekBar, 1000);  // Update the seek bar every second\n\n        // Set the device_id as the active playback device immediately.\n        const headers = {\n            'Authorization': `Bearer ${accessToken}`,\n            'Content-Type': 'application/json',\n        };\n\n        fetch('https://api.spotify.com/v1/me/player', {\n            method: 'PUT',\n            headers: headers,\n            body: JSON.stringify({\n                device_ids: [device_id],\n                // play: true\n            }),\n        }).then(response => {\n            if (!response.ok) {\n                console.error('Error setting active device:', response.statusText);\n            }\n        });\n    });\n  \n    player.connect();\n};\n\ndocument.getElementById('webPlayer').style.display = 'block';\n\ndocument.getElementById('seekBar').addEventListener('input', (e) => {\n    const newPosition = e.target.value; // This will be in milliseconds\n    player.seek(newPosition).then(() => {\n        console.log(`Moved to ${newPosition} ms`);\n    });\n});\n\nfunction formatTime(ms) {\n    const totalSeconds = Math.floor(ms / 1000);\n    const minutes = Math.floor(totalSeconds / 60);\n    const seconds = totalSeconds % 60;\n    return `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;\n}\n\nfunction updateSeekBar() {\n    player.getCurrentState().then(state => {\n        if (state) {\n            const currentPosition = state.position;\n            document.getElementById('seekBar').value = currentPosition;\n            document.getElementById('currentTime').textContent = formatTime(currentPosition);\n        }\n    });\n}\n\ndocument.getElementById('currentTime').textContent = formatTime(currentPosition);\ndocument.getElementById('totalTime').textContent = formatTime(trackDuration);\ndocument.addEventListener(\"DOMContentLoaded\", function() {\n    // Parse the URL's query parameters\n    const params = new URLSearchParams(window.location.hash.substring(1));\n    const accessToken = params.get('access_token');\n\n    if (accessToken) {\n        fetchUserProfile(accessToken).then(userProfile => {\n            if (userProfile.product !== 'premium') {\n                alert('Please upgrade to premium to use this app.');\n                window.location.href = 'https://www.spotify.com';\n            } else {\n                // Handle the logic for premium users (like setting up the web player, etc.)\n                setupWebPlayer(accessToken);\n                // Note: Ensure that \"setupWebPlayer\" function exists and is properly defined in your code.\n            }\n        }).catch(error => {\n            console.error(\"Error fetching user profile:\", error);\n            alert('There was an error fetching your Spotify profile.');\n        });\n    }\n});\n\nfunction fetchUserProfile(accessToken) {\n    return new Promise((resolve, reject) => {\n        fetch('https://api.spotify.com/v1/me', {\n            headers: {\n                'Authorization': 'Bearer ' + accessToken\n            }\n        }).then(response => response.json()).then(data => {\n            resolve(data);\n        }).catch(error => {\n            reject(error);\n        });\n    });\n}\n\n\n\n\n// Initialize the event listeners\ninitializeEventListeners();\n\n\n\n"],"names":["captureAudioButton","document","getElementById","mediaRecorder","audioChunks","onDataAvailable","event","push","data","length","async","formData","FormData","append","Blob","type","response","fetch","method","body","ok","Error","result","transcriptionBox","value","transcript","displayTranscription","json","error","console","message","sendToAPI","slice","onRecordingStop","addEventListener","state","constraints","audio","echoCancellation","autoGainControl","noiseSuppression","latency","navigator","mediaDevices","getUserMedia","then","stream","MediaRecorder","mimeType","ondataavailable","onstop","start","chunkDuration","textContent","catch","err","stop","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","__webpack_modules__","currentAccessToken","currentSpotifyUri","setupWebPlayer","accessToken","redirectToSpotify","fetchCurrentPlaying","spotifyURL","split","join","window","open","fetchWithRetry","endpoint","options","maxRetries","arguments","i","Promise","res","setTimeout","retries","headers","warn","text","item","track","uri","currentImage","src","album","images","url","name","updateCurrentPlaying","JSON","parse","e","spotifySDKReady","resolve","onSpotifyWebPlaybackSDKReady","refreshToken","localStorage","getItem","access_token","setItem","displayResults","results","resultsContainer","innerHTML","episodeResults","filter","trackResults","artistResults","showResults","geniusHeader","createElement","appendChild","forEach","appendResultToContainer","mogulHeader","podHeader","bangerHeader","container","resultElement","className","dataset","id","image","handleResultClick","currentTarget","artistId","topTracksEndpoint","status","tracks","map","getArtistTopTracks","showId","episodesEndpoint","items","episode","getShowEpisodes","itemId","itemType","uris","context_uri","log","stringify","errorBody","statusText","includes","alert","handlePlaybackError","selectedItem","Array","from","children","find","style","display","playItem","updateSeekBarInterval","player","isPlaying","togglePlay","pause","clearInterval","resume","setInterval","updateSeekBar","rewindTrack","getCurrentState","newPosition","Math","max","position","seek","fastForwardTrack","formatTime","ms","totalSeconds","floor","seconds","currentPosition","hash","location","substring","hashParams","URLSearchParams","has","get","tokenType","expiresIn","token_type","expires_in","Authorization","username","display_name","accessTokenValue","searchInput","searchResults","timer","target","border","clearTimeout","query","searchEndpoint","encodeURIComponent","popularity","artists","episodes","shows","sort","a","b","searchSpotify","setupSearch","Spotify","Player","isSupported","checkWebPlaybackSDKCompatibility","this","querySelector","getOAuthToken","callback","addListener","trackDuration","track_window","current_track","duration_ms","paused","_ref","device_id","device_ids","connect","reject","fetchUserProfile","userProfile","product","href","preventDefault","initializeAudioCapture","initializeEventListeners"],"sourceRoot":""}